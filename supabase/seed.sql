-- Table: public.users

DROP TABLE IF EXISTS public.users;

CREATE TABLE IF NOT EXISTS public.users
(
    user_id uuid NOT NULL,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    display_name text COLLATE pg_catalog."default" NOT NULL,
    email text COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT users_pkey PRIMARY KEY (user_id),
    CONSTRAINT users_user_id_fkey FOREIGN KEY (user_id)
        REFERENCES auth.users (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.users
    OWNER to postgres;

ALTER TABLE IF EXISTS public.users
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.users TO anon;

GRANT ALL ON TABLE public.users TO authenticated;

GRANT ALL ON TABLE public.users TO postgres;

GRANT ALL ON TABLE public.users TO service_role;


-- Table: public.posts

DROP TABLE IF EXISTS public.posts;

CREATE TABLE IF NOT EXISTS public.posts
(
    post_id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    user_id uuid NOT NULL,
    message text COLLATE pg_catalog."default" NOT NULL,
    thumbnail_url text COLLATE pg_catalog."default" NOT NULL,
    file_url text COLLATE pg_catalog."default" NOT NULL,
    file_type text COLLATE pg_catalog."default" NOT NULL,
    file_name text COLLATE pg_catalog."default" NOT NULL,
    aspect_ratio double precision NOT NULL,
    thumbnail_storage_id text COLLATE pg_catalog."default" NOT NULL,
    original_file_storage_id text COLLATE pg_catalog."default" NOT NULL,
    post_settings json NOT NULL DEFAULT '{}'::json,
    CONSTRAINT posts_pkey PRIMARY KEY (post_id),
    CONSTRAINT posts_user_id_fkey FOREIGN KEY (user_id)
        REFERENCES auth.users (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.posts
    OWNER to postgres;

ALTER TABLE IF EXISTS public.posts
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.posts TO anon;

GRANT ALL ON TABLE public.posts TO authenticated;

GRANT ALL ON TABLE public.posts TO postgres;

GRANT ALL ON TABLE public.posts TO service_role;
-- POLICY: Authenticated Users

DROP POLICY IF EXISTS "Authenticated Users" ON public.posts;

CREATE POLICY "Authenticated Users"
    ON public.posts
    AS PERMISSIVE
    FOR ALL
    TO authenticated
    USING ((auth.uid() = user_id))
    WITH CHECK ((auth.uid() = user_id));
-- POLICY: Enable read access for all users

DROP POLICY IF EXISTS "Enable read access for all users" ON public.posts;

CREATE POLICY "Enable read access for all users"
    ON public.posts
    AS PERMISSIVE
    FOR SELECT
    TO authenticated
    USING (true);


    -- Table: public.comments

DROP TABLE IF EXISTS public.comments;

CREATE TABLE IF NOT EXISTS public.comments
(
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    from_user_id uuid NOT NULL,
    from_post_id bigint NOT NULL,
    comment text COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT comments_pkey PRIMARY KEY (id),
    CONSTRAINT comments_from_post_id_fkey FOREIGN KEY (from_post_id)
        REFERENCES public.posts (post_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE,
    CONSTRAINT comments_from_user_id_fkey FOREIGN KEY (from_user_id)
        REFERENCES auth.users (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.comments
    OWNER to postgres;

ALTER TABLE IF EXISTS public.comments
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.comments TO anon;

GRANT ALL ON TABLE public.comments TO authenticated;

GRANT ALL ON TABLE public.comments TO postgres;

GRANT ALL ON TABLE public.comments TO service_role;
-- POLICY: Authenticated Users

DROP POLICY IF EXISTS "Authenticated Users" ON public.comments;

CREATE POLICY "Authenticated Users"
    ON public.comments
    AS PERMISSIVE
    FOR ALL
    TO authenticated
    USING ((auth.uid() = from_user_id))
    WITH CHECK ((auth.uid() = from_user_id));
-- POLICY: Enable read access for all users

DROP POLICY IF EXISTS "Enable read access for all users" ON public.comments;

CREATE POLICY "Enable read access for all users"
    ON public.comments
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING (true);


-- Storage: storage.buckets

INSERT INTO storage.buckets(
	id, name, public, avif_autodetection)
	VALUES (1, 'images', true, false);

INSERT INTO storage.buckets(
	id, name, public, avif_autodetection)
	VALUES (2, 'videos', true, false);

INSERT INTO storage.buckets(
	id, name, public, avif_autodetection)
	VALUES (3, 'thumbnails', true, false);


-- POLICY: images folder
-- POLICY: Give users delete access to own images folder

DROP POLICY IF EXISTS "Give users delete access to own images folder" ON storage.objects;

CREATE POLICY "Give users delete access to own images folder"
    ON storage.objects
    AS PERMISSIVE
    FOR DELETE
    TO authenticated
    USING (((bucket_id = 'images'::text) AND ((auth.uid())::text = (storage.foldername(name))[1])));

-- POLICY: Give users update access to own images folder

DROP POLICY IF EXISTS " Give users update access to own images folder" ON storage.objects;

CREATE POLICY " Give users update access to own images folder"
    ON storage.objects
    AS PERMISSIVE
    FOR UPDATE
    TO authenticated
    USING (((bucket_id = 'images'::text) AND ((auth.uid())::text = (storage.foldername(name))[1])));

-- POLICY: Give users insert access to own images folder

DROP POLICY IF EXISTS "Give users insert access to own images folder" ON storage.objects;

CREATE POLICY "Give users insert access to own images folder"
    ON storage.objects
    AS PERMISSIVE
    FOR INSERT
    TO authenticated
    WITH CHECK (((bucket_id = 'images'::text) AND ((auth.uid())::text = (storage.foldername(name))[1])));


-- POLICY: Give users select access to own images folder

DROP POLICY IF EXISTS "Give users select access to own images folder" ON storage.objects;

CREATE POLICY "Give users select access to own images folder"
    ON storage.objects
    AS PERMISSIVE
    FOR SELECT
    TO authenticated
    USING (((bucket_id = 'images'::text) AND ((auth.uid())::text = (storage.foldername(name))[1])));


-- POLICY: videos folder
-- POLICY: Give users delete access to own videos folder

DROP POLICY IF EXISTS "Give users delete access to own videos folder" ON storage.objects;

CREATE POLICY "Give users delete access to own videos folder"
    ON storage.objects
    AS PERMISSIVE
    FOR DELETE
    TO authenticated
    USING (((bucket_id = 'videos'::text) AND ((auth.uid())::text = (storage.foldername(name))[1])));

-- POLICY: Give users update access to own videos folder

DROP POLICY IF EXISTS " Give users update access to own videos folder" ON storage.objects;

CREATE POLICY " Give users update access to own videos folder"
    ON storage.objects
    AS PERMISSIVE
    FOR UPDATE
    TO authenticated
    USING (((bucket_id = 'videos'::text) AND ((auth.uid())::text = (storage.foldername(name))[1])));

-- POLICY: Give users insert access to own videos folder

DROP POLICY IF EXISTS "Give users insert access to own videos folder" ON storage.objects;

CREATE POLICY "Give users insert access to own videos folder"
    ON storage.objects
    AS PERMISSIVE
    FOR INSERT
    TO authenticated
    WITH CHECK (((bucket_id = 'videos'::text) AND ((auth.uid())::text = (storage.foldername(name))[1])));


-- POLICY: Give users select access to own videos folder

DROP POLICY IF EXISTS "Give users select access to own videos folder" ON storage.objects;

CREATE POLICY "Give users select access to own videos folder"
    ON storage.objects
    AS PERMISSIVE
    FOR SELECT
    TO authenticated
    USING (((bucket_id = 'videos'::text) AND ((auth.uid())::text = (storage.foldername(name))[1])));


-- POLICY: thumbnails folder
-- POLICY: Give users delete access to own thumbnails folder

DROP POLICY IF EXISTS "Give users delete access to own thumbnails folder" ON storage.objects;

CREATE POLICY "Give users delete access to own thumbnails folder"
    ON storage.objects
    AS PERMISSIVE
    FOR DELETE
    TO authenticated
    USING (((bucket_id = 'thumbnails'::text) AND ((auth.uid())::text = (storage.foldername(name))[1])));

-- POLICY: Give users update access to own thumbnails folder

DROP POLICY IF EXISTS " Give users update access to own thumbnails folder" ON storage.objects;

CREATE POLICY " Give users update access to own thumbnails folder"
    ON storage.objects
    AS PERMISSIVE
    FOR UPDATE
    TO authenticated
    USING (((bucket_id = 'thumbnails'::text) AND ((auth.uid())::text = (storage.foldername(name))[1])));

-- POLICY: Give users insert access to own thumbnails folder

DROP POLICY IF EXISTS "Give users insert access to own thumbnails folder" ON storage.objects;

CREATE POLICY "Give users insert access to own thumbnails folder"
    ON storage.objects
    AS PERMISSIVE
    FOR INSERT
    TO authenticated
    WITH CHECK (((bucket_id = 'thumbnails'::text) AND ((auth.uid())::text = (storage.foldername(name))[1])));


-- POLICY: Give users select access to own thumbnails folder

DROP POLICY IF EXISTS "Give users select access to own thumbnails folder" ON storage.objects;

CREATE POLICY "Give users select access to own thumbnails folder"
    ON storage.objects
    AS PERMISSIVE
    FOR SELECT
    TO authenticated
    USING (((bucket_id = 'thumbnails'::text) AND ((auth.uid())::text = (storage.foldername(name))[1])));
